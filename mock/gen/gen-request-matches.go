// Copyright 2021 The go-github AUTHORS. All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//
// It is meant to be used by go-github contributors in conjunction with the
// go generate tool before sending a PR to GitHub.
// Please see the CONTRIBUTING.md file for more information.
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
	"text/template"
)

const source = `// Copyright 2021 The go-github AUTHORS. All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by mock/gen/gen-request-matches.go; DO NOT EDIT.

package gen
{{ range .RequestMatchPairs }}    
var  {{.VarName}} RequestMatch = "{{.Value}}"
{{end}}

`

type RequestMatchPair struct {
	VarName string
	Value   string
}

func getPkgDir(pkgName string) string {
	_, currentLocation, _, _ := runtime.Caller(0)

	projectRootAbs, _ := filepath.Abs(path.Dir(currentLocation) + "../../..")

	return fmt.Sprintf(
		"%s/%s",
		projectRootAbs,
		pkgName,
	)
}

func main() {
	fset := token.NewFileSet()
	githubPackageDir := getPkgDir("github")
	mockGenPackageDir := getPkgDir("mock/gen")

	pkgs, err := parser.ParseDir(
		fset,
		githubPackageDir,
		func(fi os.FileInfo) bool {
			return !strings.HasSuffix(fi.Name(), "_test.go") &&
				!strings.HasPrefix(fi.Name(), "gen-") &&
				!strings.HasPrefix(fi.Name(), "github-")
		},
		0,
	)

	if err != nil {
		log.Fatal(err)
		return
	}

	requestMatchPairs := []RequestMatchPair{}

	for _, f := range pkgs["github"].Files {
		methodCallNameChan := getServiceMethodCall(f)

		for methodName := range methodCallNameChan {
			requestMatchPairs = append(requestMatchPairs, methodName)
		}

	}

	renderTemplate(mockGenPackageDir, requestMatchPairs)
}

func getServiceMethodCall(f *ast.File) <-chan RequestMatchPair {
	returnChan := make(chan RequestMatchPair)

	go func(c chan RequestMatchPair) {
		defer close(returnChan)

		for _, decl := range f.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok {
				// Skip unexported funcDecl.
				if !fn.Name.IsExported() {
					continue
				}

				// skip empty receivers or empty lists
				if fn.Recv == nil || len(fn.Recv.List) == 0 {
					continue
				}

				if receiverType, ok := fn.Recv.List[0].Type.(*ast.StarExpr); ok {
					if receiverTypeIndent, ok := receiverType.X.(*ast.Ident); ok {
						if receiverTypeIndent.Name != "" {
							varName := fmt.Sprintf(
								"RequestMatch%s%s",
								strings.Replace(
									receiverTypeIndent.Name,
									"Service",
									"",
									-1,
								),
								fn.Name.Name,
							)
							// this format matches the `runtime.Frame.Function` values
							// eg. "github.(*UsersService).Get" and "github.(*OrganizationsService).List"
							value := fmt.Sprintf(
								"github.(*%s).%s",
								receiverTypeIndent.Name,
								fn.Name.Name,
							)

							c <- RequestMatchPair{
								VarName: varName,
								Value:   value,
							}
						}
					}
				}
			}
		}
	}(returnChan)

	return returnChan
}

func renderTemplate(
	targetPackage string,
	requestMatches []RequestMatchPair,
) {
	sort.SliceStable(requestMatches, func(i, j int) bool {
		return requestMatches[i].Value < requestMatches[j].Value
	})

	// fmt.Println("requestMatches:", requestMatches)

	buf := bytes.NewBufferString("")

	template.Must(template.New("source").Parse(source)).Execute(
		buf,
		struct {
			RequestMatchPairs []RequestMatchPair
		}{
			RequestMatchPairs: requestMatches,
		},
	)

	ioutil.WriteFile(
		targetPackage+"/requestmatches.go",
		buf.Bytes(),
		0644,
	)
}
